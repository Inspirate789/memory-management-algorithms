\chapter{Анализ предметной области}

\section{Основные понятия}

Управление памятью \cite{glossary} --- это процесс координации и контроля использования памяти в вычислительной системе. Управление памятью выполняется на трёх уровнях. 

\begin{enumerate}[label*=\arabic*)]
	\item Аппаратное обеспечение управления памятью (MMU, ОЗУ и т.д.).
	\item Управление памятью операционной системы (виртуальная память, защита).
	\item Управление памятью приложения (выделение и освобождение памяти, сборка мусора).
\end{enumerate}

Аппаратное обеспечение управления памятью состоит из электронных устройств и связанных с ними схем, которые хранят состояние компьютера. Эти устройства включают в себя регистры процессора, кэш, ОЗУ, MMU (Memory Management Unit, блоки управления памятью) и вторичную (дисковую память). Конструкция запоминающих устройств имеет решающее значение для производительности современных вычислительных систем. Фактически пропускная способность памяти является основным фактором, влияющим на производительность системы. \cite{glossary}

Далее подробно будет рассмотрено управление памятью с точки зрения операционной системы и приложений.



\section{Управление памятью с точки зрения операционной системы}

В процессе развития аппаратного обеспечения была разработана концепция \textbf{иерархии памяти}, согласно которой компьютеры обладают несколькими мегабайтами очень быстродействующей, дорогой и энергозависимой кэш-памяти, несколькими гигабайтами памяти, средней как по скорости, так и по цене, а также несколькими терабайтами памяти на довольно медленных, сравнительно дешевых дисковых накопителях, не говоря уже о сменных накопителях, таких как DVD и флеш-устройства USB. Превратить эту иерархию в абстракцию, то есть в модель, а затем управлять этой абстракцией --- и есть задача операционной системы. Та часть операционной системы, которая управляет иерархией памяти (или ее частью), называется \textbf{менеджером}, или \textbf{диспетчером}, \textbf{памяти} \cite{tannenbaum}. Он предназначен для действенного управления памятью и должен следить за тем, какие части памяти используются, выделять память процессам, которые в ней нуждаются, и освобождать память, когда процессы завершат свою работу. Выбор, совершаемый менеджером памяти на этом этапе, может оказать существенное влияние на будущую эффективность программы, так как до 40\% (в среднем 17\%) времени программы затрачивают на выделение и освобождение памяти. \cite{cornell}

Чтобы допустить одновременное размещение в памяти нескольких приложений без создания взаимных помех, нужно решить две проблемы, относящиеся к защите и перемещению. Так была разработана новая абстракция операционной системы --- адресное пространство. Так же как понятие процесса создает своеобразный абстрактный центральный процессор для запуска программ, понятие адресного пространства создаёт своеобразную абстрактную память, в которой существуют программы. \textbf{Адресное пространство} \cite{tannenbaum} --- это набор адресов, который может быть использован процессом для обращения к памяти. У каждого процесса имеется собственное адресное пространство, независимое от того адресного пространства, которое принадлежит другим процессам (за исключением тех случаев, когда процессам требуется совместное использование их адресных пространств).

СТРУКТУРА АДРЕСНОГО ПРОСТРАНСТВА ПРОЦЕССА (ОПРЕДЕЛЕНИЕ КУЧИ)

Для обеспечения выполнения ???????????? были выработаны два основных подхода. Самый простой из них, называемый \textbf{свопингом}, заключается в размещении в памяти всего процесса целиком, его запуске на некоторое время, а затем сбросе на диск. Бездействующие процессы большую часть времени хранятся на диске и в нерабочем состоянии не занимают пространство оперативной памяти (хотя некоторые из них периодически активизируются, чтобы проделать свою работу, после чего опять приостанавливаются). Второй подход называется \textbf{виртуальной памятью}, он позволяет программам запускаться даже в том случае, если они находятся в оперативной памяти лишь частично.

\textbf{Виртуальная память} --- метод управления оперативной (внутренней) памятью компьютера, позволяющий выполнять программы, требующие больше оперативной памяти, чем имеется в компьютере, путём автоматического перемещения частей программы между оперативной памятью и вторичным хранилищем (файл на диске или раздел подкачки). В основе виртуальной памяти лежит идея, что у каждой программы имеется собственное адресное пространство, которое разбивается на участки, называемые \textbf{страницами} \cite{tannenbaum}. Каждая страница представляет собой непрерывный диапазон адресов. Эти страницы отображаются на физическую память, но для запуска программы одновременное присутствие в памяти всех страниц необязательно.

Если программа требует больше памяти, чем есть в распоряжении компьютера, то операционная система в соответствии с \textbf{алгоритмом замещения страниц} \cite{tannenbaum} выбирает страницы, которые выгружаются из оперативной памяти. Освобождённая оперативная память отдаётся другой программе, которая её запросила. В дальнейшем, если выгруженной странице произойдёт обращение, операционная система выберет страницу для выгрузки из памяти, чтобы освободить место для загружаемой страницы.

% Одной из задач распределения памяти является вычисление адресов для фрагментов программы и информационных объектов, исходя из фиксируемого при генерации взаимного их расположения, причем для адресов тех объектов, расположение которых в памяти нельзя определить статически (при трансляции), генерируются динамические вычисления этих адресов.

Помимо первоначального выделения памяти процессам при их создании операционная система должна также заниматься динамическим распределением памяти, то есть обслуживать запросы приложений на выделение им дополнительной памяти во время выполнения. После того как приложение перестает нуждаться в дополнительной памяти, оно может возвратить ее системе. Выделение памяти случайной длины в случайные моменты времени из общего пула памяти приводит к фрагментации и, вследствие этого, к неэффективному ее использованию. Дефрагментация памяти тоже является функцией операционной системы.

Ещё одна важная задача операционной системы --- защита памяти. Она состоит в том, чтобы не позволить выполняемому процессу записывать или читать данные из памяти, назначенной другому процессу.

Таким образом, можно сформулировать следующие функции ОС по управлению памятью в мультипрограммных системах.

\begin{enumerate}[label*=\arabic*.]
	\item Отслеживание свободной и занятой памяти.
	\item Управление виртуальными адресными пространствами процессов.
	\item Динамическое распределение памяти. 
	\item Дефрагментация памяти. 
\end{enumerate}



\section{Управление памятью с точки зрения приложений}

\subsection{Среда выполнения языка программирования}

Менеджер памяти операционной системы с точки зрения выполняющихся на ней приложений обладает двумя серьёзными недостатками. Во-первых, он является недетерминированным: процессы не могут напрямую влиять на решения, принимаемые операционной системой по управлению их адресными пространствами. Во-вторых, Менеджер памяти операционной системы не реализует те функции управления памятью, которые требуются конечному пользователю. Поэтому языки программирования реализуют собственную \textbf{среду выполнения} (language runtime), в которой реализуют необходимые пользователю функции для работы с памятью и создают собственные абстракции памяти.

Среда выполнения языка программирования может выполнять следующие функции: \cite{dotnet_clr}

\begin{enumerate}[label*=\arabic*)]
	\item управление памятью;
	\item обработка исключений; 
	\item сборка мусора; 
	\item контроль типов;
	\item обеспечение безопасности; 
	\item управление потоками. 
\end{enumerate}

Управление потоками в среде выполнения языка подразумевает, что язык программирования организует многопоточное выполнение программы, используя возможности операционной системы, а также реализует некоторую \textbf{модель памяти}, которая для параллельного императивного языка программирования определяет, какие записи в разделяемые переменные могут быть видны при чтениях, выполняемых другими потоками. \cite{memory_model}

\subsection{Управление памятью}

Менеджер памяти приложения должен учитывать следующие ограничения. \cite{glossary}

\begin{enumerate}[label*=\arabic*.]
	\item \textbf{Нагрузка на процессор} --- дополнительное время, затрачиваемое диспетчером памяти во время работы программы.
	\item \textbf{Блокировки} --- время, необходимое диспетчеру памяти для завершения операции и возврата управления программе. Это влияет на способность программы оперативно реагировать на интерактивные события, а также на любое асинхронное событие, например связанное с сетевым взаимодействием.
	\item \textbf{Накладные расходы памяти} --- дополнительный объём памяти, затрачиваемый на администрирование, а также накладные расходы, связанные с внутренней и внешней фрагментацией. \textbf{Внутренняя фрагментация} --- явление, при котором аллокатор выделяет при каждом запросе больше памяти, чем фактически запрошено. \textbf{Внешняя фрагментация} --- явление, при котором свободная память разделена на множество мелких блоков, ни один из которых нельзя использовать для обслуживания запроса ан выделение памяти.
\end{enumerate}

Управление памятью приложения объединяет две взаимосвязанные задачи: выделение памяти (allocation) и её переиспользование (recycling), когда она больше не требуется. За выделение памяти отвечает \textbf{аллокатор} \cite{allocator}. Его необходимость обусловлена тем, что процессы, как правило, не могут заранее предсказать, сколько памяти им потребуется, поэтому они нуждаются в реализации дополнительной логики обслуживания изменяющихся запросов к памяти. Решение об освобождении и переиспользовании выделенной аллокатором памяти, которая больше не используется приложением, может быть принято либо программистом, либо средой выполнения языка. Соответственно, в зависимости от этого управление памятью в языке программирования может считаться либо ручным, либо автоматическим.

\subsubsection{Ручное управление памятью}

При ручном управлении памятью программист имеет прямой контроль над временем жизни объектов программы. Как правило, это осуществляется либо явными вызовами функций управления кучей (например, malloc и free в C), либо языковыми конструкциями, влияющими на стек управления (например, объявлениями локальных переменных). Ключевой особенностью ручного менеджера памяти является то, что он дает возможность явно указать менеджеру памяти приложения, что заданная область памяти может быть освобождена и переиспользована.

Преимущества ручного управления памятью: 

\begin{itemize}[label*=---]
	\item явное выделение и освобождение памяти делает программы более прозрачными для разработчика;
	\item ручные менеджеры памяти, как правило, используют память более экономно, так как программист может минимизировать время между моментом, когда выделенная память перестаёт использоваться, и её фактическим освобождением.
\end{itemize}

Недостатки ручного управления памятью: 

\begin{itemize}[label*=---]
	\item увеличение исходного кода программ за счёт того, что управление памятью, как правило, составляет значительную часть интерфейса любого модуля;
	\item повышение дублирования кода за счёт использования однотипных инструкций управления памятью;
	\item увеличение числа ошибок управления памятью из-за человеческого фактора.
\end{itemize}

К языкам с ручным управлением памятью относятся C, C++, Zig и другие. На таких языках программисты могут писать код, дублирующий его поведение менеджера памяти либо путем выделения больших блоков и их разделения для использования, либо путем внутреннего переиспользования этих блоков. Такой код называется \textbf{субаллокатором} (suballocator) \cite{glossary}, так как он работает поверх другого аллокатора. Субаллокаторы могут использовать как преимущество специальные знания о поведении программы, но в целом они менее эффективны, чем использование базового аллокатора. Также стоит отметить, что субаллокаторы могут быть неэффективными или ненадежными, тем самым создавая новый источник ошибок.



\subsubsection{Автоматическое управление памятью}

Описание и подводка к сборке мусора



\subsection{Сборка мусора}

Понятие и определение сборщика мусора.

Определение неиспользуемого объекта в памяти?

\subsubsection{Подсчёт ссылок}



\subsubsection{Трассирующая сборка мусора}



Большинство современных языков программирования строятся на одной из трех ссылочных моделей:

Первая категория это языки с ручным управлением временем жизни объектов. Примеры — C/C++/Zig. В этих языках объекты аллоцируются и освобождаются вручную, а указатель — это просто адрес памяти, никого ни к чему не обязывающий.

Во вторую категорию попадают языки с подсчетом ссылок. Это Оbjective-C, Swift, Частично Rust, C++ при использовании умных указателей и некоторые другие. Эти языки позволяют автоматизировать до некоторой степени удаление ненужных объектов. Но это имеет свою цену. В многопоточный среде такие счетчики ссылок должны быть атомарными, а это дорого. К тому же, подсчет ссылок не может освободить все виды мусора. Когда объект А ссылается на объект Б а объект Б обратно ссылается на объект А такая закольцованная иерархия не может быть удалена подсчетом ссылок. Такие языки как Rust, Swift вводят дополнительные не владеющие ссылки которые решают проблему закольцовок ценой усложнения объектной модели и синтаксиса.

В третью категорию попадают большинство современных языков программирования. Это языки с автоматической сборкой мусора: Java, JavaScript, Kotlin, Python, Lua... В этих языках ненужные объекты удаляются автоматически, но есть нюанс. Сборщик мусора потребляет очень много памяти и процессорного времени. Он включается в случайные моменты времени и ставит основную программу на паузу. Иногда полностью — на все свое время работы, иногда частично. Сборки мусора без пауз не существует. Гарантию сборки всего мусора может дать только алгоритм который просматривает всю память и останавливает приложение на все свое время работы. В реальной жизни такие сборщики давно не используются ввиду своей неэффективности. В современных системах некоторые мусорные объекты не удаляются вообще.

Кроме того, само определение ненужного объекта нуждается в уточнении. Если, например, у нас есть GUI-приложение, и вы убираете с формы какой-то управляющий элемент, подписанный на события таймера, он не может быть удален просто так потому что где-то в объекте таймера хранится ссылка на этот объект, и сборщик мусора не будет считать такой объект мусором.

Как уже говорилось выше, каждая из трех ссылочных моделей имеет свои недостатки. В первом случае имеем дыры в memory safety и  утечки памяти, во втором случае мы имеем медленную работу в многопоточной среде и утечки памяти из-за закольцовок, в третьем получаем спорадические остановки программы сильное потребление памяти, процессора и необходимость ручного разрыва ссылок когда объект становится не нужным. К тому же система с подсчетом ссылок и сборкой мусора не позволяют управлять временем жизни других ресурсов — таких как открытые файловые дескрипторы, идентификаторы окон, процессов, шрифтов и так далее. Эти методы рассчитаны только на память. Есть еще одна проблема систем со сборкой мусора — виртуальная память. В условиях, когда программная система накапливает мусор, а затем сканирует память для его освобождения, вытеснение части адресного пространства на внешний носитель может полностью убить производительность приложения. Поэтому сборка мусора не совместима с виртуальной памятью.

То есть проблемы есть и текущие методы их решения имеют изъяны.



Язык C++ разрабатывался с расчетом на использование ручного управления памятью. Некоторые
языковые возможности, такие как адресная арифметика и приведение
типов указателей, затрудняют реализацию сборщиков мусора для этого
языка. Несмотря на это, существует ряд подходов к сборке мусора для
языка C++.



Одни из самых неприятных ошибок, которые портят жизнь программисту, это, безусловно, ошибки, связанные с управлением памятью. В таких языках, как C и C++, в которых управление памятью целиком возложено на программиста, львиная доля времени, затрачиваемого на отладку программы, приходится на борьбу с подобными ошибками.

Давайте перечислим типичные ошибки при управлении памятью (некоторые из них особенно усугубляются в том случае, если в программе существуют несколько указателей на один и тот же блок памяти):

Преждевременное освобождение памяти (premature free). Эта беда случается, если мы пытаемся использовать объект, память для которого была уже освобождена. Указатели на такие объекты называются висящими (dangling pointers), а обращение по этим указателям дает непредсказуемый результат.

Двойное освобождение (double free). Иногда бывает важно не перестараться и не освободить ненужный объект дважды.

Утечки памяти (memory leaks). Когда мы постоянно выделяем новые блоки памяти, но забываем освобождать блоки, ставшие ненужными, память в конце концов заканчивается.

Фрагментация адресного пространства (external fragmentation). При интенсивном выделении и освобождении памяти может возникнуть ситуация, когда непрерывный блок памяти определенного размера не может быть выделен, хотя суммарный объем свободной памяти вполне достаточен. Это происходит, если используемые блоки памяти чередуются со свободными блоками и размер любого из свободных блоков меньше, чем нам нужно.

Проблема особенно критична в серверных приложениях, работающих в течение длительного времени.

В программах, работающих в среде .NET, все вышеперечисленные ошибки никогда не возникают, потому что эти программы используют реализованное в CLR автоматическое управление памятью, а именно – сборщик мусора.

Работа сборщика мусора заключается в освобождении памяти, занятой ненужными объектами. При этом сборщик мусора также умеет «двигать» объекты в памяти, тем самым устраняя фрагментацию адресного пространства.

Все эти чудеса, которые творит сборщик мусора, возможны исключительно благодаря тому, что во время выполнения программы известны типы всех используемых в ней объектов. Другими словами, данные, с которыми работает программа, находятся под полным контролем среды выполнения и называются, соответственно, управляемыми данными (managed data).
